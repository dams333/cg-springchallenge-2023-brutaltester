package com.codingame.game;

import java.util.*;

/**
 * Code generated by ChatGPT
 * 
 * <pre>
    prompt:
      You are given a graph, where each node has a positive integer value. The path-value of a path is the value of the node that has the smallest value in that path. Given a node A and a node B, find the path from A to B that has the maximum path-value.
    answer:
      To find the path from node A to node B that has the maximum path-value, we can use Dijkstra's algorithm, a commonly used algorithm for finding the shortest path in a graph.

      In this case, we will modify the algorithm slightly to find the maximum path-value. Instead of keeping track of the shortest distance from the starting node to all other nodes, we will keep track of the maximum path-value from the starting node to all other nodes.

      Here are the steps to follow:

      Initialize a set of visited nodes and a set of unvisited nodes. Set the maximum path-value for each node to negative infinity, except for node A, which should be set to its own value.

      While the set of unvisited nodes is not empty, select the unvisited node with the maximum path-value and mark it as visited.

      For each unvisited neighbor of the current node, calculate the potential maximum path-value to that neighbor by taking the minimum of the current node's maximum path-value and the neighbor node's value.

      If the potential maximum path-value is greater than the current maximum path-value for the neighbor node, update the neighbor node's maximum path-value.

      Repeat steps 2-4 until the target node B has been visited, or until all reachable nodes have been visited.

      If the maximum path-value for node B is still negative infinity, then there is no path from A to B.

      Otherwise, we can reconstruct the maximum path from A to B by starting at node B and repeatedly selecting the neighbor with the maximum path-value until we reach node A.

      This algorithm has a time complexity of O(|E| + |V| log |V|), where |E| is the number of edges and |V| is the number of nodes in the graph.
    prompt: 
      Could you provide a Java implementation?
 * </pre>
 *
 */
public class MaximumPathValue {

    // Class to represent a node in the graph
    static class Node {
        int value;
        int maxPathValue;
        List<Node> neighbors;

        public Node(int value) {
            this.value = value;
            this.maxPathValue = Integer.MIN_VALUE;
            this.neighbors = new ArrayList<>();
        }
    }

    public static int getMaxPathValue(Node start, Node end) {
        // Initialize sets of visited and unvisited nodes
        Set<Node> visited = new HashSet<>();
        Set<Node> unvisited = new HashSet<>();
        unvisited.add(start);

        // Initialize maximum path-value for each node
        start.maxPathValue = start.value;
        for (Node node : start.neighbors) {
            node.maxPathValue = Math.min(start.maxPathValue, node.value);
            unvisited.add(node);
        }

        // Dijkstra's algorithm to find maximum path-value
        while (!unvisited.isEmpty()) {
            Node current = null;
            int maxPathValue = Integer.MIN_VALUE;
            for (Node node : unvisited) {
                if (node.maxPathValue > maxPathValue) {
                    current = node;
                    maxPathValue = node.maxPathValue;
                }
            }
            if (current == null) {
                // No path from start to end
                return Integer.MIN_VALUE;
            }
            unvisited.remove(current);
            visited.add(current);
            if (current == end) {
                // Found path from start to end
                return end.maxPathValue;
            }
            for (Node neighbor : current.neighbors) {
                if (!visited.contains(neighbor)) {
                    int potentialMaxPathValue = Math.min(current.maxPathValue, neighbor.value);
                    if (potentialMaxPathValue > neighbor.maxPathValue) {
                        neighbor.maxPathValue = potentialMaxPathValue;
                        unvisited.add(neighbor);
                    }
                }
            }
        }
        // No path from start to end
        return Integer.MIN_VALUE;
    }

    public static void main(String[] args) {
        // Example graph:
        //   2
        //  / \
        // 1   3
        //  \ /
        //   4
        Node A = new Node(1);
        Node B = new Node(2);
        Node C = new Node(3);
        Node D = new Node(4);
        A.neighbors.add(B);
        A.neighbors.add(D);
        B.neighbors.add(A);
        B.neighbors.add(C);
        C.neighbors.add(B);
        C.neighbors.add(D);
        D.neighbors.add(A);
        D.neighbors.add(C);

        int maxPathValue = getMaxPathValue(A, D);
        System.out.println("Maximum path-value from A to D: " + maxPathValue); // Expected output: 2
    }
}
